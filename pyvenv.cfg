import numpy as np
import pygame as pg
import sys
import random as rn
#DEFINING THE PLAYER AND THE OBSTACLES:
player_h = 50 
player_w = 45
player_x = 100
player_y = 315

obs_h = 40
obs_w = 45
obs_x = 0
obs_y = 318

coin_h = 25
coin_w = 27
coin_x = 0
coin_y = 175
#PLAYER CLASS:
class player:
    def __init__(self,height,width,x_cor,y_cor,image):
        self.height = height
        self.width = width
        self.x_cor = x_cor
        self.y_cor = y_cor
        self.image = image
        self.mask = pg.mask.from_surface(self.image)
        self.jumping = False
        self.flying = False
        self.jet_pack = 0
        self.jumping_count = 9
        self.flying_count = 9
#OBSTACLE CLASS: 
class obstacle:
    def __init__(self,height,width,x_cor,y_cor,image):
        self.height = height
        self.width = width
        self.x_cor = x_cor
        self.y_cor = y_cor
        self.image = image
        self.mask = pg.mask.from_surface(self.image)
        self.comming = False

#INNITIALIZING SOME PARAMETERS OF THE GAMEING SCREEN:
WHITE = (255,255,255)
BLACK = (0,0,0)
GREY = (192,192,192)
YELLOW = (255,255,26)
GREEN = (0,255,20)
x_pixel = 1000
y_pixel = 500
#INNITIALIZING THE GAME:
pg.init()  #innitializing pygame
gamescreen = pg.display.set_mode((x_pixel, y_pixel))  #loading the gamming screen:
pg.font.init() #innitializing on-screen font(FONT INNITIALIZING IS SHAPERATELY DONE)
score = -2
font = pg.font.SysFont("Westminster", 40) #WESTMINSTER IS A FONT TYPE INSTALLED IN THE PROJECT FILE

#LOADING THE IMAGES FROM THEIR FILES:
dino_1 = pg.image.load("D:\\AI_games\\dino dude v2\\images\\dino 1.png").convert_alpha() # convert_alpha() converts the image from png format
dino_2 = pg.image.load("D:\\AI_games\\dino dude v2\\images\\dino 2.png").convert_alpha() # to pygame readable format with transparent background
dino_3 = pg.image.load("D:\\AI_games\\dino dude v2\\images\\dino dude 3 copy.png").convert_alpha()
dino_4 = pg.image.load("D:\\AI_games\\dino dude v2\\images\\dino_fly.png").convert_alpha() #convert() can also be used but it does not
cactus = pg.image.load("D:\\AI_games\\dino dude v2\\images\\cactus new.png").convert_alpha() #innitiate transparent background
coin_1 = pg.image.load("D:\\AI_games\\dino dude v2\\images\\coins2.png").convert_alpha()
coin_2 = pg.image.load("D:\\AI_games\\dino dude v2\\images\\coins.png").convert_alpha()
dino = dino_1
coin_img = coin_1

#CREATING THE PLAYER AND THE OBSTACLES:
p = player(player_h,player_w,player_x,player_y,dino)
obs_1 = obstacle(obs_h,obs_w,obs_x,obs_y,cactus)#maximum two obstacle can be present on the screen.
obs_2 = obstacle(obs_h,obs_w,obs_x,obs_y,cactus)
coin = obstacle(coin_h,coin_w,coin_x,coin_y,coin_img)#coin is a part of obstacle.

#CREATING THE GAME:
playing = True
running_count = 0
jump_count = p.jumping_count
flying_count = p.flying_count
speed = 0
coin_count = 0
counter_2x = 0
#CREATING THE GAMEPLAY FUNCTION:
def gameplay():
    global speed
    global score
    global playing
    global running_count
    global jump_count
    global flying_count
    global dino
    global coin_count
    global coin_img
    global counter_2x

    delay = 45
    #INNITIALIZING THE GAMMING LOOP:
    while playing:
        fontdisp_1 = font.render("Score: " + str(score *10), False, BLACK)
        fontdisp_2 = font.render("Fuel: ", False, BLACK)
        fontdisp_3 = font.render("2x bar: ", False, BLACK)
        pg.time.delay(delay)
        #CREATING THE EXIT FROM THE GAME:
        for event in pg.event.get():
            if event.type == pg.QUIT or (event.type == pg.KEYDOWN and event.key == pg.K_ESCAPE):
                playing = False
        keys = pg.key.get_pressed()  #creating key variable to define keys:
        #CREATING JUMPING OF THE PLAYER:
        if p.jumping == False and p.flying == False:
            if keys[pg.K_SPACE]:
                p.jumping = True
        elif p.jumping == True:
            if jump_count >= -p.jumping_count:
                neg = 1
                if jump_count < 0:
                    neg = -1
                p.y_cor -= (jump_count ** 2) * 0.5 * neg #equation for jumping.
                jump_count -= 1
            else:
                jump_count = p.jumping_count
                p.jumping = False
        #CREATING THE FLYING WITH JETPACK:
        if p.flying == False and p.jumping == False:#for flying any of jumping and flying should not take place.
            if keys[pg.K_UP]:
                p.flying = True
        elif p.flying == True:
            if flying_count >= -p.flying_count:
                if flying_count > 0:
                    p.y_cor -= (flying_count ** 2) * 0.5
                    flying_count -= 1
                if flying_count == 0:
                    p.jet_pack -= 1#discharging of the jetpack.
                    if p.jet_pack <= 0 or keys[pg.K_DOWN]:
                        flying_count -= 1
                if flying_count < 0:
                    p.y_cor -= (flying_count ** 2) * 0.5 *(-1)
                    flying_count -= 1
            else:
                flying_count = p.flying_count
                p.flying = False

        if p.jet_pack <= 20 and not p.flying:
                    p.jet_pack += 0.05#charging of the jetpack.

        #CREATING THE LEG MOVEMENT OF THE DINO DUDE:
        if running_count %2 == 0:
            if dino == dino_1:
                dino = dino_2
            else: dino = dino_1
        if p.jumping == True:
            dino = dino_3
        if p.flying == True:
            dino = dino_4
        running_count += 1

        #CREATING THE COMMING OF THE OBSTACLES ONE AFTER THE OTHER:
        if not obs_1.comming:
            obs_1.x_cor = rn.randint(1000,1300)
            obs_1.comming = True
            if counter_2x > 0:
                score += 2
            else: score += 1
        else:
            if obs_1.x_cor > 0:
                obs_1.x_cor -= 10 +speed
            else: obs_1.comming = False

        if not obs_2.comming:
            obs_2.x_cor = rn.randint(1500,1700)
            obs_2.comming = True
            if counter_2x > 0:
                score += 2
            else: score += 1
        else:
            if obs_2.x_cor > 0:
                obs_2.x_cor -= 10 +speed
            else: obs_2.comming = False
        if counter_2x > 0:
            counter_2x -= 0.2

        speed += 0.01

        #CREATING THE COMMING OF COIN:
        if not coin.comming and coin_count %500 == 0:
            coin.x_cor = rn.randint(1500,1700)
            coin.comming = True
        else:
            if coin.x_cor > -30:
                coin.x_cor -= 11 +speed
            else: coin.comming = False
        coin_count += 1

        # The following collision logic pixel perfect collision. The collision is true when the pixels overlap.
        #COLLISION WITH THE OBSTACLES:
        offset_1 = (int(np.round(p.x_cor - obs_1.x_cor)), int(np.round(p.y_cor - obs_1.y_cor)))
        collide_1 = obs_1.mask.overlap(p.mask, offset_1)
        offset_2 = (int(np.round(p.x_cor - obs_2.x_cor)), int(np.round(p.y_cor - obs_2.y_cor)))
        collide_2 = obs_2.mask.overlap(p.mask, offset_2)
        if collide_1 or collide_2:
            playing = False

        #COLLISION WITH COIN:
        offset_3 = (int(np.round(p.x_cor - coin.x_cor)), int(np.round(p.y_cor - coin.y_cor)))
        collide_3 = coin.mask.overlap(p.mask, offset_3)
        if collide_3:
            counter_2x = 50
            coin.x_cor = -30

        #Note: All of the pygame functions accept only integer arguments so,
        #in the off set tuple player.cordinate - obstacle.co-ordinate has to be integers to fit in the
        #overlap function, but while jumping or flying the co-ordinate of the player constantly changes
        #and often take non-integer values since the equation for juming is nonlinear quadratic equation.
        #Hence we have to convert these float/decimal values to the nearest rounded of integers which also
        #give sufficiently good results for pixel perfect collision.

        #CREATING THE SCREEN AND BLITTING THE PLAYER, OBSTACLE, AND COIN ON THE SCREEN:
        gamescreen.fill(GREY)
        gamescreen.blit(coin_img, (coin.x_cor, coin.y_cor))
        gamescreen.blit(cactus, (obs_1.x_cor, obs_1.y_cor))
        gamescreen.blit(cactus, (obs_2.x_cor, obs_2.y_cor))
        gamescreen.blit(dino, (p.x_cor, p.y_cor))
        gamescreen.blit(fontdisp_1, (760, 20))
        gamescreen.blit(fontdisp_2, (15, 20))
        gamescreen.blit(fontdisp_3, (15, 55))
        pg.draw.lines(gamescreen, BLACK, False, [(0, 350), (1000, 350)], 2)
        pg.draw.lines(gamescreen, YELLOW, False, [(80, 35), (80 + (p.jet_pack * 10) + 5, 35)], 30)
        pg.draw.lines(gamescreen, GREEN, False, [(110, 75), (110 + (counter_2x * 5) + 5, 75)], 20)
        pg.display.update()

    pg.quit()

gameplay()
print(score * 10)
sys.exit()
